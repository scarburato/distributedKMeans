% !TeX spellcheck = en_US
\documentclass[parskip=full]{report}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
%\usepackage{beramono}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xcolor}
\usepackage[a4paper, margin={3cm}]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{svg}
\usepackage{subcaption}
\usepackage{float}
\usepackage{pdfpages}
\usepackage{algorithmicx}
\usepackage[ruled]{algorithm}
\usepackage{algpseudocode}

\usepackage{tikz}

\usepackage{hyphenat}
\usepackage[english]{babel}
% Carattere monospaziato di default
\renewcommand{\ttdefault}{pcr}

\tikzstyle{block} = [draw, fill=blue!20, rectangle, 
minimum height=3em, minimum width=6em]
\tikzstyle{sum} = [draw, fill=blue!20, circle, node distance=1cm]
\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]

\lstset{
	% wrap long lines on new line
	postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
	breaklines=true, 
	columns=fullflexible,
	% tab and fonts
	tabsize=2,
	basicstyle=\ttfamily\small,
	% theme
	numbers=left,
	rulecolor=\color{black!30},	
	% UTF8 and escape
	escapeinside={\%TEX}{\^^M},
	inputencoding=utf8,
	extendedchars=true,
	literate={á}{{\'a}}1 {à}{{\`a}}1 {é}{{\'e}}1 {è}{{\`e}}1,
}


% Title Page
\title{
	\includegraphics[width=0.333\textwidth]{assets/unipi1.png} \\
	\textsc{University of Pisa} \\
	\vspace{.5cm}
	Artificial Intelligence and Data Engineering \\
	Cloud Computing \\
	\vspace{2cm}
	{\huge \textit{K-Means} on MapReduce}
}

\author{
	The \textbf{Don Matteo} group: \\
	\vspace{.3cm} \\
	\begin{tabular}{lr}
		Dario Pagani & 585281 \\
		Ricky Marinsalda & 585094 \\
		Giulio Bello & 603078
	\end{tabular}
}

\begin{document}
\maketitle
\tableofcontents


\chapter{Algorithm to select initial centroids}

\section{Idea}

\paragraph{}
To run the \textit{K-means} algorithm is necessary to select $k$ initial centroids, they can either be selected statically by the user --- that is as an algorithm's parameter --- or stochastically from the data; in the latter case they could either be drawn randomly with uniform probability or by employing a probability function that changes the likelihood to draw an element accordingly to certain metrics. For simplicity's sake our implementation chooses the $k$ initial point with equal probability.

\paragraph{}
We used a \textit{Map-Reduce} procedure to draw those those $k$ point

\section{Implementation}

\paragraph{Key}
This \textit{MapReduce} procedure doesn't use a key, so only one reducer will
be spawned by the framework, in our \textit{Hadoop} implementation we used the
\texttt{NullWritable} data-type as output key to reduce traffic.

\paragraph{Mapper}
The mapper assigns a random label to each data point, this value is not be confused with the \textit{MapReduce}'s key; finally it emits the tuple made of the label and the data point.

\paragraph{Combiner and Reducer}
Then, the combiner sorts the tuples by their label and emits the first $k$
smallest labels and their samples. Finally, the reducer performs the same
operations as the combiner, emitting $k$ values.

\paragraph{Probability}
If the data are split equally among the nodes and the random numbers generator generates all numbers with equal probability, then all dataset's samples have circa equal probability to be drawn.

\paragraph{Complexity}
Let $n = |D|$ the number of samples, $N$ the number of nodes and $k$ the number of samples to draw; then the time complexity is

\[
T \in O \left(\dfrac{n}{N} \cdot \left(1 + \log(k)\right)\right)
\]

and the space complexity is

\[
S \in \Theta \left(k\right)
\]

if a sorted data structure is used to store only the first $k$ smallest labels
and their associated data.

\begin{algorithm}[H]
	\caption{Random select}\label{alg:random_map}
	\begin{algorithmic}
		\Require $k \in \mathbb{N}^+$
		\Procedure{Mapper}{nLine, $r$}
			\State $I \gets \Call{rand}{\;}$
				\Comment{Assign a random number to each file's row}
			\State \Return $\left< \texttt{null}, \left< I, r\right> \right>$
				\Comment{Constant key for all lines}
		\EndProcedure
		\vspace{.25cm}
		\Procedure{Combiner}{$S$}
			\State $L$ is a data structure \textbf{ordered} by key $I$
				\Comment{E.g. a binary search tree}
			\State $L \gets \emptyset$
			\While{$S \neq \emptyset$}
				\State $\left< \texttt{null}, \left< I, r\right> \right> \
					\gets \Call{read}{S}$
					\Comment{Read data from the mapper (or combiners)}
				%\State $L \gets L \bigcup \left\{ \left< I, r\right>\right\}$
				\State \Call{insert}{$L$, $\left< I, r\right>$}
				\If{$|L| > k$}
					\Comment{We store at most $k + 1$ elements}
					\State \Call{pop\_last}{L}
					\Comment{We remove the last element (sorted by $I$)}
				\EndIf

				\State \Call{next}{$S$}
			\EndWhile
			\ForAll{$ \left< I, r\right> \in L$}
				\State \Call{emitt}{$\left< \texttt{null}, \left< I, r\right> \right>$}
			\EndFor
		\EndProcedure
		\vspace{.25cm}
		\Procedure{Reducer}{$S$}
			\State \Call{Combiner}{$S$} \Comment{Same as the combiner}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\chapter{K-means}

	The following two classes, \texttt{Point} and \texttt{AverageBuilder}, are utilized to facilitate the required computations to implement the K-means algorithm using the MapReduce paradigm.

	\section{\texttt{Point} Class}

	The \texttt{Point} class represents a point in a $d$-dimensional space. It 
	offers the following functionalities:

	\begin{itemize}
		\item Setting the components of a point, performing mathematical operations (addition, subtraction, scalar multiplication), calculating distance, and converting to/from string representation.
		\item Implementation of the \texttt{Writable} interface to support serialization and deserialization.

	\end{itemize}

	\section{\texttt{AverageBuilder} Class}

	The \texttt{AverageBuilder} class aids in computing the average of multiple points. It provides the following features:

	\begin{itemize}
		\item Storage of the sum of points and their cardinality (number of points).
		\item Methods to add points to the computation, either individually or by combining with another \texttt{AverageBuilder} object.
		\item Computation and retrieval of the average point.
		\item Implementation of the \texttt{Writable} interface for serialization and deserialization.
	\end{itemize}

	The \texttt{Point} class handles point-related operations in the Mapper and Reduce classes, while the \texttt{AverageBuilder} class facilitates efficient computation of the average of multiple points used in the combiner and reducer.



\section{Pseudo-code}

\subsection{Mapper}
The map phase of the k-means algorithm is responsible for assigning each data point to the nearest cluster center. It involves calculating the distance between the input data point and each centroid, where all centroids are stored globally and accessible to every mapper. The map phase keeps track of the index of the cluster center that has the minimum distance to the data point. The output of the map function is a key-value pair, where the key represents the index of the nearest cluster center, and the value remains as the data point itself.


	\begin{algorithm}
		\caption{KMeansMapper}
		\begin{algorithmic}[1]


			\Procedure{Map}{key, $p$, centroids}
			\State minDistance $\gets \infty$
			\State closestCentroid $\gets -1$
			\For{$i \gets 0$ \textbf{to} length(centroids)-1}
			\State distance $\gets$ calculateDistance(centroids[$i$], $p$)
			\If{distance $\geq$ minDistance}
			\State \textbf{continue}
			\EndIf
			\State closestCentroid $\gets i$
			\State minDistance $\gets$ distance
			\EndFor
			\State \textbf{return} (closestCentroid, $p$)

			\EndProcedure
		\end{algorithmic}
	\end{algorithm}


\subsection{Reducer}

\begin{algorithm}
	\caption{KMeansReducer}\label{algo:kmeans-reducer}
	\begin{algorithmic}[1]
		\Procedure{reduce}{key, values}
		\State sum $\gets$ 0
		\State cardinality $\gets$ 0
		\For{\textbf{each} value \textbf{in} values}
		\State sum $\gets$ sum + value
		\State cardinality $\gets$ cardinality + 1
		\EndFor

		\State new\_center $\gets$  $\dfrac{sum}{cardinality}$
		\State \textbf{return} (key, new\_center)
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\chapter{Results}


\end{document}          
